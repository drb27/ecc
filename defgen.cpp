#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <vector>
#include <exception>
using namespace std;

#include "sassert.h"
#include "warning.h"
#include "ctree.h"
#include "version.h"
#include "ast.h"
using namespace ecc::ast;

#include "indent.h"
#include "generator.h"
#include "defgen.h"
#include "globals.h"

namespace ecc
{
    string defgen::tl_head(outfile_t fileType, const string& fHeader)
    {
    	stringstream ss;

    	ss << "/**" << endl;
    	ss << " * Generated by:         " << ecc::version << endl;
    	ss << " * Generation timestamp: " << currenttime();
    	ss << " */" << endl;
	
	if (fileType==outfile_t::codeFile)
	{
	    ss << "#include <string>" << endl;
	    ss << "#include <sstream>" << endl;
	    ss << "using namespace std;" << endl << endl;
	    ss << "#include \"" << leaf(fHeader) << "\"" << endl;
	}

    	return ss.str();
    }

    string defgen::tl_typedef(const enumdef& ed)
    {
    	stringstream ss;
    	ss << endl << ind() << "typedef enum {";
	ind++;

    	string sep = "";

	const ast::values_t& values = ed.getvalues();
    	for ( auto member : ed.getmembers() )
    	{
    	    ss << sep << endl << ind() << member;
    	    if (values.at(member)!=AST_DEFAULT_ENUM_VALUE)
    		ss << "=" << values.at(member);
    	    sep = ",";
    	}

	ind--;
    	ss << endl << ind() << "} " << ed.get_name() << ";" << endl;
    	return ss.str();
    }

    string defgen::tl_prototype(const enumdef& item, outfile_t fileType)
    {
    	stringstream ss;
	string ext,trm,name;
	
	if (fileType==outfile_t::headerFile)
	{
	    ext = "extern ";
	    trm = ";";
	}

	name = item.get_name();

	if (item.is_flags())
	    ss << ind() << ext << "string getstr_" << name << "("
	       << name << " v)" << trm << endl;
	else
	{
	    const string ls = (fileType==outfile_t::headerFile)?
		"=false":"";
	    ss << ind() << ext << "const string& getstr_" << name << "("
	       << name << " v, bool longStr" << ls << ")" << trm << endl;
	}
	
    	return ss.str();
    }

    string defgen::tl_codebody(const elist_t& items)
    {
	stringstream ss;

	// Constants first
	ss << tl_constants(items);

	// Then access functions, by nested namespace
	ss << namespace_functions(NsTree);

	return ss.str();
    }

    string defgen::tl_constants(const elist_t& items)
    {
	stringstream ss;
	ss << ind() << "namespace {" << endl;
	ind++;
	ss << ind() << "static const string notfound=\"\";" << endl;
	
    	for ( auto pItem : items )
    	{
	    const string fqns = pItem->nspace()->fqn("_");

	    // Loop through the regular strings
    	    for ( auto member : pItem->getmembers() )
    	    {
    		ss << ind() << "static const string " << fqns << "_" << 
		    pItem->get_name() << "_" << member << " = " << "\"" 
		   << member << "\";" << endl;
    	    }

	    // Loop through the longstrings
	    for ( auto member : pItem->getmembers() )
	    {
		const string& ls = pItem->getlstring(member);
		if ( !ls.empty() )
		{
		    ss << ind() << "static const string " << fqns << "_" 
		       << pItem->get_name() << "_l_"
		       << member << " = " << "\"" << ls << "\";" << endl;
		}
	    }
    	}

	ind--;
    	ss << ind() << "}" << endl;
	return ss.str();
    }

    string defgen::tl_function_regular(const enumdef& item)
    {
	stringstream ss;

	// Generate code prototype
	ss << endl << tl_prototype(item,outfile_t::codeFile);

	// Body
	ss << ind() << "{" << endl;
	ind++;

    	ss << ind() << "switch (v) {" << endl;
	ind++;
	
    	for ( auto member : item.getmembers() )
    	{
    	    ss << ind() << "case " << member << ":" << endl;
	    ind++;

	    const string& ls = item.getlstring(member);
	    const string fqns = item.nspace()->fqn("_");
	    if (!ls.empty())
	    {
		ss << ind() << "return (longStr)?"
		   << fqns << "_" << item.get_name() << "_l_" << member
		   << ":" << fqns << "_" << item.get_name() << "_" << member << ";" << endl;
	    }
	    else
	    {
		ss << ind() << "return " << fqns << "_" << item.get_name() 
		   << "_" << member << ";" << endl; 
	    }
	    ind--;
    	}

    	ss << ind() << "default: " << endl;
	ind++;
    	ss << ind() << "return notfound;" << endl;
	ind--;

	ind--;
    	ss << ind() << "}" << endl;

	ind--;
    	ss << ind() << "}" << endl;

	return ss.str();
    }

    string defgen::tl_function_flags_attr(const enumdef& item)
    {
	stringstream ss;

	// Generate code prototype
	ss << endl << tl_prototype(item,outfile_t::codeFile);
	ss << ind() << "{" << endl;
	ind++;
	
    	ss << ind() << "stringstream ss;" << endl;
    	ss << ind() << "bool sep=false;" << endl;
	
	const string fqns = item.nspace()->fqn("_");
    	for ( auto member : item.getmembers() )
    	{
    	    ss << ind() << "if ( v & " << member << ") { if (sep) ss << \",\"; "
    	       << " ss << " << fqns << "_" << item.get_name() << "_" << member 
    	       << "; sep=true; }" << endl;
    	}
    	ss << ind() << "return ss.str();" << endl;
    	
	ind--;
	ss << ind() << "}" << endl;

	return ss.str();
    }
    
    string defgen::namespace_structures(ctree<enumdef>& root)
    {
	indent& myind = ind;
	stringstream ss;

	auto ns_start = 
	    [&ss,&myind,this](const ctree<enumdef>& node) -> void 
	    {
		if (!node.is_root())
		{
		    ss << endl << myind() << "namespace " << node.name() << " {" << endl;
		    myind++;
		}

		for ( auto ped : node.members() )
		{
		    ss << tl_typedef(*ped);
		}

		ss << endl;

		for ( auto ped : node.members() )
		{
		    ss << tl_prototype(*ped,outfile_t::headerFile);
		}
	    };

	auto ns_end = 
	    [&ss,&myind](const ctree<enumdef>& node) -> void
	    {
		if (!node.is_root())
		{
		    myind--;
		    ss << myind() << "}" << endl;
		}
	    };

	root.dfs( ns_start, ns_end );
	return ss.str();
    }

    string defgen::namespace_functions(ctree<enumdef>& root)
    {
	indent& myind = ind;
	stringstream ss;

	auto ns_start = 
	    [&ss,&myind,this](const ctree<enumdef>& node) -> void 
	    {
		if (!node.is_root())
		{
		    ss << endl << myind() << "namespace " << node.name() << " {" << endl;
		    myind++;
		}

		// Access functions
		for ( auto i : node.members() )
		{
		    if (i->is_flags())
			ss << tl_function_flags_attr(*i);
		    else
			ss << tl_function_regular(*i);
		}
	    };

	auto ns_end = 
	    [&ss,&myind](const ctree<enumdef>& node) -> void
	    {
		if (!node.is_root())
		{
		    myind--;
		    ss << myind() << "}" << endl;
		}
	    };

	root.dfs( ns_start, ns_end );
	return ss.str();
    }

}   
